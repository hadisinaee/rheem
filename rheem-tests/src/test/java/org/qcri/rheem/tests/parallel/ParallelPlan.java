package org.qcri.rheem.tests.parallel;

import org.qcri.rheem.basic.operators.*;
import org.qcri.rheem.core.api.Configuration;
import org.qcri.rheem.core.api.RheemContext;
import org.qcri.rheem.core.function.FunctionDescriptor;
import org.qcri.rheem.core.function.PredicateDescriptor;
import org.qcri.rheem.core.plan.rheemplan.RheemPlan;
import org.qcri.rheem.core.types.DataSetType;
import org.qcri.rheem.java.Java;
import org.qcri.rheem.spark.Spark;
import org.qcri.rheem.tests.util.PlatformsTest;

import java.util.Collection;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * {@link ParallelPlan} is an structure that allow create objects
 * that are forced to be executed in some {@link org.qcri.rheem.core.platform.Platform},
 * also allow the generation of plan without have a input, because
 * the source will be generated by a collections
 *
 * @param <Type1> original type that come from the source
 * @param <Type2> type after the map or simple convertions
 */
public abstract class ParallelPlan<Type1, Type2> {

    /**
     * original type that come from the source
     */
    protected final Class<Type1> type1Class;

    /**
     * type after the map or simple convertions
     */
    protected final Class<Type2> type2Class;

    /**
     * sed that will be use to generate the collection
     */
    protected final Type1 seed;

    /**
     * generator of the collections
     */
    protected final UnaryOperator<Type1> generator;

    /**
     * is the context that will customize the variables to force the
     * execution in parallel mode
     */
    protected RheemContext rheemContext;

    /**
     * Constructor of {@link ParallelPlan}
     *
     * @param typeClass original type that come from the source
     * @param type2Class type after the map or simple convertions
     * @param seed sed that will be use to generate the collection
     * @param generator generator of the collections
     */
    public ParallelPlan(Class<Type1> typeClass, Class<Type2> type2Class, Type1 seed, UnaryOperator<Type1> generator) {
        this.type1Class = typeClass;
        this.type2Class = type2Class;
        this.seed = seed;
        this.generator = generator;

        //set the variable to be enable to run in parallel mode
        Configuration conf = new Configuration();
        conf.setProperty("rheem.core.optimizer.enumeration.parallel-tasks", "true");
        this.rheemContext = new RheemContext(conf);
        this.rheemContext.register(Java.basicPlugin());
        this.rheemContext.register(Spark.basicPlugin());
    }

    /**
     * Generate a collection of lenght equal the size {@code size}, currently the implementation
     * is an correlative starting from {@code 0}
     *
     * @param size is the lenght of the collection that will be generated
     * @return {@link Collection} of {@link Type1} of the size described in the parameters
     */
    protected Collection<Type1> generateCollectionSource(long size) {
        return Stream.iterate(this.seed, this.generator).limit(size).collect(Collectors.toList());
    }

    /**
     * generate the {@link CollectionSource} that will be used in the plan,
     * and set the variable where need to be executed
     *
     * @param size of the collection that will be use
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link CollectionSource} that will be part of one branch in the {@link RheemPlan}
     */
    protected CollectionSource<Type1> generateSource(long size, PlatformsTest platformsTest) {
        return this.generateSource(
            this.generateCollectionSource(size),
            platformsTest
        );
    }

    /**
     * generate the {@link CollectionSource} that will be used in the plan,
     * and set the {@link org.qcri.rheem.core.platform.Platform} where need to be executed
     *
     * @param size of the collection that will be use
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link CollectionSource} that will be part of one branch in the {@link RheemPlan}
     */

    /**
     * generate the {@link CollectionSource} that will be used in the plan,
     * and set the {@link org.qcri.rheem.core.platform.Platform} where need to be executed
     *
     * @param source is the collection that will be use by the {@link CollectionSource}
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link CollectionSource} that will be part of one branch in the {@link RheemPlan}
     */
    protected CollectionSource<Type1> generateSource(Collection<Type1> source, PlatformsTest platformsTest) {
        CollectionSource<Type1> source_base = new CollectionSource<Type1>(source, this.type1Class);
        source_base.addTargetPlatform(platformsTest.getPlatform());
        return source_base;
    }

    /**
     * generate the {@link FilterOperator} of type {@link Type1}that will be used in the plan,
     * and set the {@link org.qcri.rheem.core.platform.Platform} where need to be executed
     *
     * @param udf function that will be excuted in the {@link FilterOperator}
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link FilterOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected FilterOperator<Type1> generateFilterType1(PredicateDescriptor.SerializablePredicate<Type1> udf, PlatformsTest platformsTest) {
        FilterOperator<Type1> filter_base = new FilterOperator<Type1>(udf, this.type1Class);
        filter_base.addTargetPlatform(platformsTest.getPlatform());
        return filter_base;
    }

    /**
     * generate the {@link FilterOperator} of type {@link Type2}that will be used in the plan,
     * and set the {@link org.qcri.rheem.core.platform.Platform} where need to be executed
     *
     * @param udf function that will be excuted in the {@link FilterOperator}
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link FilterOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected FilterOperator<Type2> generateFilterType2(PredicateDescriptor.SerializablePredicate<Type2> udf, PlatformsTest platformsTest) {
        FilterOperator<Type2> filter_base = new FilterOperator<Type2>(udf, this.type2Class);
        filter_base.addTargetPlatform(platformsTest.getPlatform());
        return filter_base;
    }

    /**
     * @see ParallelPlan#generateMap(FunctionDescriptor.SerializableFunction, Class, Class, PlatformsTest)
     *
     * @param udf function that will be excuted in the {@link MapOperator}
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @return {@link MapOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected MapOperator<Type1, Type2> generateMapType1_2(FunctionDescriptor.SerializableFunction<Type1, Type2> udf, PlatformsTest platformsTest){
        return this.generateMap(
            udf,
            this.type1Class,
            this.type2Class,
            platformsTest
        );
    }

    /**
     * generate the {@link MapOperator} that will get as input {@link Input} and will return {@link Output},
     * that operator be used in the plan and set the {@link org.qcri.rheem.core.platform.Platform}
     * where need to be executed
     *
     * @param udf function that will be excuted in the {@link MapOperator}
     * @param inputClass type of the tuples that will as input
     * @param outputClass type of the tuples that will be outputed
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Input> the class of the input
     * @param <Output> the class of the output
     * @return {@link MapOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Input, Output> MapOperator<Input, Output> generateMap(
        FunctionDescriptor.SerializableFunction<Input, Output> udf,
        Class<Input> inputClass,
        Class<Output> outputClass,
        PlatformsTest platformsTest
    ){
        MapOperator<Input, Output> map_base = new MapOperator<Input, Output>(udf, inputClass, outputClass);
        map_base.addTargetPlatform(platformsTest.getPlatform());
        return map_base;
    }

    /**
     * @see ParallelPlan#generateJoin(FunctionDescriptor.SerializableFunction, FunctionDescriptor.SerializableFunction, Class, Class, Class, PlatformsTest)
     *
     * @param keyExtractor1 key extractor of type {@link Type1}
     * @param keyExtractor2 key extractor of type {@link Type1}
     * @param keyClass class output of the extractors
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Key> type of the output of the extractors, this is considered the key of join
     * @return {@link JoinOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Key> JoinOperator<Type1, Type1, Key> generateJoinType1(
        FunctionDescriptor.SerializableFunction<Type1, Key> keyExtractor1,
        FunctionDescriptor.SerializableFunction<Type1, Key> keyExtractor2,
        Class<Key> keyClass,
        PlatformsTest platformsTest
    ){
        return this.generateJoin(
            keyExtractor1,
            keyExtractor2,
            this.type1Class,
            this.type1Class,
            keyClass,
            platformsTest
        );
    }

    /**
     * @see ParallelPlan#generateJoin(FunctionDescriptor.SerializableFunction, FunctionDescriptor.SerializableFunction, Class, Class, Class, PlatformsTest)
     *
     * @param keyExtractor1 key extractor of type {@link Type2}
     * @param keyExtractor2 key extractor of type {@link Type2}
     * @param keyClass class output of the extractors
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Key> type of the output of the extractors, this is considered the key of join
     * @return {@link JoinOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Key> JoinOperator<Type2, Type2, Key> generateJoinType2(
        FunctionDescriptor.SerializableFunction<Type2, Key> keyExtractor1,
        FunctionDescriptor.SerializableFunction<Type2, Key> keyExtractor2,
        Class<Key> keyClass,
        PlatformsTest platformsTest
    ){
        return this.generateJoin(
            keyExtractor1,
            keyExtractor2,
            this.type2Class,
            this.type2Class,
            keyClass,
            platformsTest
        );
    }

    /**
     * @see ParallelPlan#generateJoin(FunctionDescriptor.SerializableFunction, FunctionDescriptor.SerializableFunction, Class, Class, Class, PlatformsTest)
     *
     * @param keyExtractor1 key extractor of type {@link Type1}
     * @param keyExtractor2 key extractor of type {@link Type2}
     * @param keyClass class output of the extractors
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Key> type of the output of the extractors, this is considered the key of join
     * @return {@link JoinOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Key> JoinOperator<Type1, Type2, Key> generateJoinType1_2(
        FunctionDescriptor.SerializableFunction<Type1, Key> keyExtractor1,
        FunctionDescriptor.SerializableFunction<Type2, Key> keyExtractor2,
        Class<Key> keyClass,
        PlatformsTest platformsTest
    ){
        return this.generateJoin(
            keyExtractor1,
            keyExtractor2,
            this.type1Class,
            this.type2Class,
            keyClass,
            platformsTest
        );
    }

    /**
     * @see ParallelPlan#generateJoin(FunctionDescriptor.SerializableFunction, FunctionDescriptor.SerializableFunction, Class, Class, Class, PlatformsTest)
     *
     * @param keyExtractor1 key extractor of type {@link Type2}
     * @param keyExtractor2 key extractor of type {@link Type1}
     * @param keyClass class output of the extractors
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Key> type of the output of the extractors, this is considered the key of join
     * @return {@link JoinOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Key> JoinOperator<Type2, Type1, Key> generateJoinType2_1(
        FunctionDescriptor.SerializableFunction<Type2, Key> keyExtractor1,
        FunctionDescriptor.SerializableFunction<Type1, Key> keyExtractor2,
        Class<Key> keyClass,
        PlatformsTest platformsTest
    ){
        return this.generateJoin(
            keyExtractor1,
            keyExtractor2,
            this.type2Class,
            this.type1Class,
            keyClass,
            platformsTest
        );
    }


    /**
     * generate the {@link JoinOperator} that will get as input {@link T1} and {@link T2} and will
     * use as key {@link Key}, that operator be used in the plan and
     * set the {@link org.qcri.rheem.core.platform.Platform} where need to be executed
     *
     * @param keyExtractor1 key extractor of type {@link T1}
     * @param keyExtractor2 key extractor of type {@link T2}
     * @param t1Class class where will be apply extractor1
     * @param t2Class class where will be apply extractor2
     * @param keyClass class output of the extractors
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <T1> type of the input of extractor1
     * @param <T2> type of the input of extractor2
     * @param <Key> type of the output of the extractors, this is considered the key of join
     * @return {@link JoinOperator} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    private <T1, T2, Key> JoinOperator<T1, T2, Key> generateJoin(
        FunctionDescriptor.SerializableFunction<T1, Key> keyExtractor1,
        FunctionDescriptor.SerializableFunction<T2, Key> keyExtractor2,
        Class<T1> t1Class,
        Class<T2> t2Class,
        Class<Key> keyClass,
        PlatformsTest platformsTest
    ){
        JoinOperator<T1, T2, Key> join_base = new JoinOperator<T1, T2, Key>(
            keyExtractor1,
            keyExtractor2,
            t1Class,
            t2Class,
            keyClass
        );
        join_base.addTargetPlatform(platformsTest.getPlatform());
        return join_base;
    }

    /**
     * generate the {@link LocalCallbackSink} that will get as output {@link Output},
     * that operator will be used in the plan and with a specific
     * {@link org.qcri.rheem.core.platform.Platform}, where need to be executed
     *
     * @param collector place where the output will be saved
     * @param outputType {@link DataSetType} that describe the output class
     * @param platformsTest {@link org.qcri.rheem.core.platform.Platform} where will be executed the {@link org.qcri.rheem.core.plan.rheemplan.Operator}
     * @param <Output> class of the output
     *
     * @return {@link LocalCallbackSink} that will be executed in a specific {@link org.qcri.rheem.core.platform.Platform}
     */
    protected <Output> LocalCallbackSink<Output> generateSink(Collection<Output> collector, DataSetType<Output> outputType, PlatformsTest platformsTest){
        LocalCallbackSink<Output> sink_base = LocalCallbackSink.createCollectingSink(collector, outputType);
        sink_base.addTargetPlatform(platformsTest.getPlatform());
        return sink_base;
    }

    /**
     * Get the {@link RheemContext} with the variable needs to execute the plans
     * in parallel if is possible to do it
     *
     * @return a {@link RheemContext} with the variables customs
     */
    public RheemContext getRheemContext() {
        return rheemContext;
    }

    /**
     * create a plan that can be use in the execution of the parallel, because
     * have to branch on in java and the other in spark, but both of them can
     * be executed in parallel
     *
     * @return {@link RheemPlan} which will be executed in parallel mode, this contains
     * a join where the branch will be excuted in two independes platforms.
     */
    public abstract RheemPlan createPlan();

    /**
     * get the object where the final result of result is stored
     *
     * @return an object where is stored the output of the plan
     */
    public abstract Object getOutput();
}
